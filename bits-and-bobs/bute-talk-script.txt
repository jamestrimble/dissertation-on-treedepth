Thank PACE committee and optil.io team for their work in organising and running the challenge.


# The Treedepth Problem

To briefly recap, a TD decomposition of a given connected graph is a rooted tree on the vertex set of G, such that for any edge in G, the endpoints of the edge have an ancestor-descendant relationship in the tree.

The tree depth of a graph is the minimum depth of a treedepth decomposition.


# Elimination trees

An important concept for the Bute algorithm is an elimination tree. I’ll give a slightly unusual definition for this, which is equivalent to the standard definitions. An elimination tree is a TDD with the following property. For every subtree of the decomposition, the subgraph of the input graph induced by the subtree’s vertex set is connected.

Give examples.

Elimination trees have the useful property that there always exists an elimination tree whose depth equals the tree depth of the graph.  So the Bute algorithm searches for an elimination tree rather than a general tree depth decomposition. This avoids having to deal with disconnected subgraphs.


# Context

The Bute algorithm that I will describe in this talk is a bottom-up, positive instance driven dynamic programming algorithm. At its heart, it is similar to the algorithm for tree depth in Bannach and Berndt’s WADS 2019 paper. In turn, that paper generalises work by Tamaki on PID algorithms for treewidth, which performed very well in PACE 2016 and PACE 2017.

Finally, Ganian and coauthors introduced a SAT encoding for treedepth. While this is not competitive with the PACE Challenge solvers, it introduced a number of useful kernelisation and domination rules. My algorithm uses a version of that paper’s domination rule.

To avoid any confusion, I will briefly mention that I presented an earlier algorithm for tree depth at SEA 2020. This is very different from the Bute algorithm, and is quite a lot slower than the leading PACE Challenge entries.


# Running example

The Bute solver solves the optimisation problem as a sequence of decision problems. It looks for an elimination tree of depth 1, then depth 2 and so on until it is successful.  I’ll use the graph shown as a running example in this talk, with the goal of finding an elimination tree of depth 4.  …


# A Sketch of the Algorithm

I’ll begin by briefly sketching the Bute algorithm. Very informally, it begins by finding vertices that look like they could be leaf nodes of some elimination tree of appropriately low depth. The key requirement here is that the vertices have sufficiently low degree in the input graph. In our example, the collection generated at this step will at least include vertices 9, 6, and 3 since, as you can see here, they _are_ leaf nodes of an elimination tree.

The second step is to find sets of vertices corresponding to subtrees rooted one level from the bottom of an elimination tree. The collection generated at this step will clearly contain the three sets shown. This collection is created by joining together some elements of the first collection along with a new vertex for the root of the subtree; I’ll talk more about this joining operation later.

Next, we go one level higher, and find all sets of vertices that could be the vertex set of a subtree rooted at depth 2 of an elimination tree.

Finally, we repeat this process at at depth 1. I’m omitting lots of details for now, but this step shows whether or not an elimination tree of the required depth exists.

We call these collections generated by the algorithm S_4^4 to S_1^4, where the subscript corresponds to the depth at which the subtree is rooted and the superscript says that our target depth is 4.


# The algorithm

Now I’ll give a more precise definition of these collections of sets.  S_i^k contains all subsets S of the vertex set of G satisfying the following three conditions.
First, the subgraph of G induced by S is connected (since this is required by the definition of an elimination tree)
Second, that induced subgraph has small tree depth.
Third, S has few neighbours in G, since these must be ancestors of the corresponding subtree in the overall elimination tree. 

These three conditions are all necessary conditions for a set to be the vertex set of a subtree rooted at the corresponding depth. In the case of depth 1, they are also sufficient conditions.

So, in a nutshell, the algorithm for the decision problem is to create S_4^4, then S_3^4, S_2^4 and finally S_1^4. If S_1^4 is empty, the instance is unsatisfiable. If it contains the vertex set of the graph, it is satisfiable. It is possible to the generate an elimination tree with a small amount of extra bookkeeping, which I won’t describe here.
 
I’ll now show these S collections in more detail for our example graph, and then in a few slides I will show how to use the elements of collection S_{I+1}^4 to generate the collection S_i^4.



—-
This slide shows collection S_4^4 of candidate leaf nodes for the elimination tree. There are eight of these; the table shows three of them. The first column shows the singleton sets. The second column shows the corresponding induced subgraphs in blue with their small sets of  neighbours in grey, and the third column shows elimination trees for these subgraphs.

—-
This slide shows collection S_3^4 - the candidate vertex sets for subtrees rooted at depth 3. Again, the table shows the set, the induced subgraph, and an elimination tree.
——
This slide shows collection S_2^4 - the candidate vertex sets for subtrees rooted at depth 2. I’ll talk shortly about how these are created. 
——
And finally this slide shows collection S_1^4. Because the set is non-empty, the decision problem is satisfiable.


# Combining subtrees

To show how one S_i^k collection is generated from the previous one, I will give an example of generating an element of S_2^4. This slide shows the elements of S_3^4. The idea is that we find a subset of this collection that could correspond to sibling subtrees of an elimination tree. The sets must therefore be disjoint and not joined by any edge in the input graph. They also must have at least one neighbour in common, but the union of their neighbourhoods must be small.

In this example, the two highlighted sets - {2,3} and {5,6}, satisfy these properties. We then try the possible roots for the subtree. First we’ll try vertex 4. This leads to a set which has only one neighbour in graph G, so it satisfies all the conditions for membership of S_2^4. If we try vertex 1 as the root, on the other hand, it creates a set with too many neighbours, so it is not added to S_2^4.


# Trie data structure

Let’s go back to the collection S_3^4. The first column of the table shows the elements of this collection, and the second column shows their neighbourhoods. When try to combine these sets, an obvious first step would be to choose one of the sets, and test each of the other sets for compatibility. But the S collections for some of the PACE Challenge instances have over a million elements, so this simple approach becomes too slow.

Instead, the Bute algorithm stores the collection in a trie data structure, with the neighbourhood of each set sorted and viewed as a string of vertices. For example, the highlighted set in the table is shown highlighted here in the trie.

At this point in the algorithm, the only sets that are compatible with {3,4} are ones whose neighbourhood contains no vertices other than 2 or 5; otherwise the combined neighbourhood would be too large. So when we traverse the trie in search of compatible sets, we can backtrack at the red nodes.

I have also tried using this kind of trie in Tamaki’s PID algorithm for tree width, and it seems to give slight speed-ups at the expense of using more memory than Tamaki’s block sieve data structure.
