\chapter{The Maximum Common Edge Subgraph Problem}
\label{c:mcsplite}

\section{McSplit-L}

?? Write about how we can use McSplit on the line graphs to solve MCES.

\section{A CP model}

We have implemented three constraint program models for MCES in the MiniZinc language.
In each case, we assume without loss of generality that the pattern graph has no more vertices than the target graph.

?? Write about models 1 and 2.

Our third model (\cref{fig:model3}) includes variables for both vertex mappings and edge mappings.
There is one variable for each vertex in the pattern graph, and one value
for each vertex in the target graph.  An alldifferent constraint over the set of variables ensures
that no target vertex is used twice.  

In addition, there is one variable for each pattern edge, and two values for
each target edge---one for each of the two possible orientations.  We also have
an additional value $\bot$ signifying that the pattern edge is not used.  A set
of constraints ensures that an edge variable takes a particular edge value if
and only if the vertex variables corresponding to the pattern edge's endpoints
take the values corresponding to the target edge's endpoints.

The objective value is the count of variables that take non-$\bot$ values.


\begin{figure}
\vspace{.8em}
\footnotesize
\begin{verbatim}
int: np;                 % order of pattern graph
int: nt;                 % order of target graph

int: mp;                 % size of pattern graph
int: mt;                 % size of target graph * 2
                         %   (i.e. number of oriented edges)

set of int: VP = 1..np;  % pattern vertices
set of int: VT = 1..nt;  % target vertices

array[VP, VP] of int: P; % adjacency matrix of pattern graph
array[VT, VT] of int: T; % adjacency matrix of target graph

array[1..mp, 1..2] of int: PE; % edge list of pattern graph
array[1..mt, 1..2] of int: TE; % oriented edge list of target graph

array[VP] of var VT: m;  % pattern vertex -> target vertex mappings
array[1..mp] of var 0..mt: m_edge;  % pattern edge index -> target
                                    %   edge index mappings. 0 means _|_

var 1..mp: objval;

constraint forall (i in 1..mp, j in 1..mt)
        (m_edge[i]==j <-> (m[PE[i,1]]==TE[j,1] /\ m[PE[i,2]]==TE[j,2]));
constraint objval = sum (a in m_edge) (a != 0);
constraint alldifferent(m);

solve :: int_search(m_edge, first_fail, indomain_split, complete)
        maximize objval;
\end{verbatim}
\vspace{-1em}
\caption{The third MiniZinc model}\label{fig:model3}
\end{figure}

\section{McSplit-E}

!!! We always branch on edges; never on vertex assignments

Our second dedicated solver for MCES, McSplit-E, shares the compact data
structures and the forward-checking of McSplit, and uses a similar partitioning
algorithm to filter domains.  However, McSplit-E does not use line graphs, but
rather models the problem directly, with a variable for each pattern edges and a value
for each \textit{oriented} target edge.  Edges are stored as ordered pairs; thus the mapping
$(1,2) \rightarrow (3,4)$ indicates not only that edge $\{1,2\}$ of the pattern graph is
mapped to edge $\{3,4\}$ of the target graph, but also that vertices $1$ and $2$ are mapped
to vertices $3$ and $4$ respectively (rather than the other way round).

We use the example graphs in \cref{fig:splitp-example} to illustrate McSplit-E's data structures.
\begin{figure}[htb]
    \centering
    \input{20-mcsplite/splitp-example}
    \caption{Example graphs $P$ and $T$}
    \label{fig:splitp-example}
\end{figure}

Initially, each pattern edge has all four
target edges and $\bot$ in its domain.  Moreover, each pattern edge can be mapped to a target edge in either orientation
(thus, in our example, $(1,2) \rightarrow (a,b)$ and $(1,2) \rightarrow (b,a)$ are both valid mappings). 
We could store the three domains separately (for example, with an identical nine-element list for each domain).
Rather than doing this, we store the same
information using two arrays and an integer.  The first array is a list of pattern edges;
the second array is a list of target edges. Finally, we store the integer 2 to signify that either orientation of a
target edge may be chosen (for example, edge $(1,2)$ may be mapped to either $(a,b)$ or $(b,a)$).
Thus, before any edge assignments are made, the domains are stored as:

\begin{align*}
    [(1,2), (1,3), (2,3)] & \qquad [(a,b), (a,c), (b,c), (c,d)] & 2
\end{align*}

Now, suppose that the algorithm has made the tentative assignment of pattern edge $(1,2)$ to target edge $(a,c)$.
Edge $(1,3)$ has $(a,b)$ and $\bot$ in its domain, while edge $(2,3)$ has $(c,b)$, $(c,d)$
and $\bot$ in its domain.  These domains are stored as follows (with the 1 at the end of
each line signifying that only the shown orientation of each target edge is permitted).

\begin{align*}
    [(1,3)] & \qquad [(a,b)]        & 1 \\
    [(2,3)] & \qquad [(c,b), (c,d)] & 1
\end{align*}

We can view the McSplit approach (where values correspond to vertices in the target line graph, and
thus effectively correspond to unoriented edges in the original target graph)
as delaying the decision of which way to orient the target
edges until after finding an optimal solution.
McSplit-E, by contrast, makes orientation decisions as early as possible.


\begin{algorithm}[htb]
\footnotesize
\DontPrintSemicolon
\nl $\FuncSty{EdgesIncidentToVertex}(E,v)$ \;
\nl \Begin{
\nl   $E' = \emptyset$ \;
\nl   \For{$(u,w) \in E$}{
\nl     \LeftComment{If this edge is incident to $v$, add the edge to $E'$ with $v$ stored as the first vertex.} \;
\nl     \lIf{u=v}{$E' = E' \cup (u,w)$}
\nl     \lElseIf{w=v}{$E' = E' \cup (w,u)$}
}
\nl   $\KwSty{return}$~$E'$ \;
}
\;
\nl $\FuncSty{EdgesNotIncidentToVertex}(E,v)$ \;
\nl \Begin{
\nl   $\KwSty{return}$~$\{(u,w) \in E \mid u\not=v \wedge w\not=v\}$ \;
}
\;
\nl $\FuncSty{Refine}(\AlgVar{future},E,v,t)$ \;
\nl \Begin{
\nl    $\AlgVar{future'} \gets \emptyset$ \label{NewFuture} \;
\nl    $E' \gets E$ \;
\nl    \For {$\langle \setG,\setH,a \rangle \in future$ \label{InnerLoop}}{
\nl        $\setG' \gets \FuncSty{EdgesIncidentToVertex}(\setG,v)$ \label{NewPWithEdge} \;
\nl        $\setH' \gets \FuncSty{EdgesIncidentToVertex}(\setH,t)$ \;
\nl        \If {$\setG' \neq \emptyset$ \bf{and} $\setH' \neq \emptyset$}{
\nl          \lIf {$a=2$}{
               $\AlgVar{future'} \gets \AlgVar{future'} \cup \{\langle \setG', \setH', 1 \rangle\}$
             }
\nl          \lElse{
               $E' \gets E' \cup (g,h)$ where $g$ is the unique element of $\setG'$ and $h$ is the unique element of $\setH'$ \label{AddToE}
             }
           }
\nl        $\setG' \gets \FuncSty{EdgesNotIncidentToVertex}(\setG,v)$ \label{NewPWithoutEdge} \;
\nl        $\setH' \gets \FuncSty{EdgesNotIncidentToVertex}(\setH,t)$ \;
\nl        \If {$\setG' \neq \emptyset$ \bf{and} $\setH' \neq \emptyset$}{
              $\AlgVar{future'} \gets \AlgVar{future'} \cup \{\langle \setG', \setH', a \rangle\}$
           }
       }
\nl   $\KwSty{return}$~$(\AlgVar{future'}, E')$ \;
}
\;
\nl $\FuncSty{Search}(\AlgVar{future},M,E)$ \;
\nl \Begin{
%\nl \lIf {$\AlgVar{future} = \emptyset$ \bf{and} $|M| > |\AlgVar{incumbent}|$}
\nl \lIf {$|E| > |\AlgVar{incumbent}|$}{$\AlgVar{incumbent} \gets E$} \label{StoreIncumbent}
%\nl \lIf {$\AlgVar{future} = \emptyset$}{return}
\medskip
\nl $\AlgVar{bound} \gets |E|  + \sum_{\langle \setG,\setH,a \rangle \in \AlgVar{future}} \min(|\setG|,|\setH|)$ \label{CalcBound} \;
\nl \lIf {$\AlgVar{bound} \leq |\AlgVar{incumbent}|$}{\KwSty{return}} \label{PruneSearch}
\medskip
\nl $\langle \setG,\setH,a \rangle \gets \FuncSty{SelectLabelClass}(\AlgVar{future})$ \label{SelectClass} \;
\nl $(v,w) \gets \FuncSty{SelectEdge}(\setG)$ \label{SelectEdge} \;
\nl \For {$(t,u) \in \setH$ \label{WLoop}} {
\nl    \If {$a=2$}{  \label{aEqualsTwo}
\nl        $(\AlgVar{future'}, E') \gets \FuncSty{Refine}(\AlgVar{future}, E, v, t)$ \;
\nl        $(\AlgVar{future''}, E'') \gets \FuncSty{Refine}(\AlgVar{future'}, E', w, u)$ \;
\nl        $\FuncSty{Search}(\AlgVar{future''}, M\cup \{(v,t)\} \cup \{(w,u)\}, E'')$ \label{ExpandWithtu} \;
       } \Else {
\nl        $(\AlgVar{future'}, E') \gets \FuncSty{Refine}(\AlgVar{future}, E, w, u)$ \;
\nl        $\FuncSty{Search}(\AlgVar{future'}, M \cup \{(w,u)\}, E')$ \label{ExpandWithu} \;
       }
  }
\nl $\setG' \gets \setG \setminus \{(v,w)\}$ \label{RemoveVW} \;
\nl $\AlgVar{future} \gets \AlgVar{future} \setminus \{\langle \setG,\setH \rangle\}$\;
\nl \lIf {$\setG' \neq \emptyset$} {$\AlgVar{future} \gets \AlgVar{future} \cup \{\langle \setG',\setH \rangle \}$}
\nl $\FuncSty{Search}(\AlgVar{future},M,E)$ \label{ExpandWithoutVW} \;
}
\;
\nl $\FuncSty{McSplitE}(\graphG,\graphH)$ \label{McSplitFun} \;
\nl \Begin{
    \nl $\KwSty{global}~\AlgVar{incumbent} \gets \emptyset$ \;
\nl $\FuncSty{Search}(\{\langle E(\graphG),E(\graphH) \rangle \},\emptyset,\emptyset)$ \label{FirstExpandCall} \;
\nl $\KwSty{return}$~$\AlgVar{incumbent}$ \;
}
\caption{Finding a maximum common subgraph.}
\label{McSplitAlg}
\end{algorithm}

We now describe McSplit-E (pseudocode for which appears in \cref{McSplitAlg})
in more detail.
We begin our description with the $\FuncSty{Refine}$ function.  Given a set of label-classes
$\AlgVar{future}$ and a vertex mapping $(v,t)$, this function
creates a refined set of label-classes that results from the vertex mapping,
any also moves implied edge-edge mappings to $E$.  Each label-class is split into at most
two new label classes---one class for edges that include $v$ (in the pattern graph) or $t$
(in the target graph), and one for edges that do not contain $v$ or $t$.  If both sets in a new
label-class are non-empty, it is included in $\AlgVar{future'}$.  \Lineref{AddToE} deals with the
special case where the edges contain $v$ or $t$, and the other endpoints have already been mapped.
In this case, it is safe to move the single edge mapping in this label-class to $E$.\footnote{Alternatively,
we could put edge mappings in $E$ in the $\FuncSty{Search}$ function instead, when we make a mapping decision
in the for-loop.  In practice, this is less efficient.  ?? why?}

The recursive procedure,
$\FuncSty{Search}$, has three parameters.  The parameter $\AlgVar{future}$ is a
list of label classes, each represented as a $\langle \setG, \setH, a\rangle$
triple.  In this triple, $\setG$ and $\setH$ are sets of edges in the two
graph.  The integer $a$ takes the value 2 if target edges may be used in either
orientation, and the value 1 if pattern edges may only be mapped to pattern
edges in the stored orientation.\footnote{In the latter case, all edges in
$\setG$ start with the same vertex $v$, all edges in $\setH$ start with the
same vertex $w$, and $v$ has already been mapped to $w$.}  The parameter $M$ is
the current mapping of vertices, and $E$ is the current mapping of edges.  On
each call to $\FuncSty{Search}$, the following invariants hold:

\begin{itemize}
    \item a pair of edges may be added to $E$ if and only if they belong to the same label class in $\AlgVar{future}$
    \item the target-graph edge in this pair may have its vertices reversed if and only if the label class has integer tag 2
    \item $((v,w),(t,u)) \in E \implies (v,t) \in M \wedge (w,u) \in M$ 
\end{itemize}

(Note that the following constraint may not be satisfied:
\[
(v,t) \in M \wedge (w,u) \in M \wedge \{v,w\} \in E(\graphG) \wedge \{t,u\} \in E(\graphH) \implies ((v,w),(t,u)) \in E.
\]

This does not affect correctness, but does imply that our model does not propagate as strongly MiniZinc model 3,
even if that model is solved using only forward checking.)

\Lineref{StoreIncumbent} stores the current edge mapping $E$ if it is large enough
to unseat the incumbent.  \Linerangeref{CalcBound}{PruneSearch} prune the
search when a calculated upper bound is not larger than the incumbent.

The remainder of the procedure performs the search.  A label class $\langle
\setG, \setH, a \rangle$ is selected from $\AlgVar{future}$ using some
heuristic (\lineref{SelectClass}); from this label class, an edge $(v,w)$ is
selected from $\setG$ (\lineref{SelectEdge}). We now iterate over all edges
$(t,u)$ in $\setH$, exploring the consequences of adding $((v,w),(t,u))$ to $E$
and adding the corresponding vertex mappings $(v,t)$ and $(w,u)$ to $M$
(\linerangeref{WLoop}{ExpandWithu}).  The $\FuncSty{Refine}$ function
creates a refined set of label-classes that results from a vertex mapping,
any also moves implied edge-edge mappings to $E$.

If $a=2$ (\lineref{aEqualsTwo}), then we have to use $\FuncSty{Refine}$ to propagate
both endpoint mappings.  Otherwise, we know that the first endpoint must already have
been mapped in an earlier recursive call, and it is sufficient to propagate only the second
endpoint mapping.  
A recursive call is made (\lineref{ExpandWithtu} or \lineref{ExpandWithu}),
on return from which we remove the edge mapping $((v,w),(t,u))$.
Having explored all possible mappings of $(v,w)$ with edges in $\setH$ we now
consider what happens if $(v,w)$ is not matched
(\linerangeref{RemoveVW}{ExpandWithoutVW}).

We start our search at the function $\FuncSty{McSplitE}$ (\lineref{McSplitFun}),
with graphs $\graphG$ and $\graphH$ as inputs.  This function returns a mapping of
maximum cardinality.  In \lineref{FirstExpandCall} the initial call is made to
$\FuncSty{Search}$; at this point we have a single label-class containing all
vertices, and the mappings $M$ and $E$ are empty.

